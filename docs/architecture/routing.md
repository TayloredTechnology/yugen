# Routing

A methodical step by step API Test Driven Development approach has been taken to implement routing for each of the serverless functions where the API can be described quickly and effectively for logic backfill.

This approach is not intended as a replacement for Agile / Kanban methodologies, but rather a revolving implementation approach for ongoing semantic versioning.

Everything is built ontop of Express, partly because this is the fastest performing framework (next to vanilla node) in 2017 https://raygun.com/blog/node-js-performance-2017/ but mostly as this framework works in all serverless environments to provide nested routing for complex functions.

## Architecture

### NanoServices Isolated from eachother
**Yūgen** uses a tight coupling between NanoServices and their respective test specifications. For maximum compatibility **Mocha** was used as it enables operation with **Wallabyjs** so tests run concurrently with development.

Each NanoService is an Express Sub-Route, with the Function Being the parent Express Route

A subtle shift was introduced from traditional express routing to allow this functionality, largely inspired from http://evanshortiss.com/development/javascript/2016/04/15/express-testing-using-ioc.html

Changing from
```
// Mount user route to the express app, we specify "/users" as the path
app.use('/users', userRoute);
```
to
```
// Have user route mount itself to the express application, we could pass
// other parameters too, such as middleware, or the mount path
userRoute(app);
```

Thus each spec file gets to operate in isolation.

### NanoServices verify execution against design

Developing a new NanoService starts by creating the relevant named .js & .spec.js files. For Sanity these live alongside eachother instead of in the legacy /src /tst directory approach.

This is where your personal approach has options, you can either create the OpenAPI / Swagger descriptions first or describe the api via tests, which mock and run a NVP (No Viable Product) approach quicker.

If following the second approach then create the specs against mocks. We use **TestDouble** for this due to its awesome ability to mock out nested 'require' in files

When the relevant code has been completed, just remove the 'test.skip()' from the spec and execution will verify against your completed code. It was a specific architectural decision to execute tests twice for each route, once for the mock and another time for actual written code.

This dual execution ensures that documentation and design is always kept current and breaking errors quickly highlight the drift from design intent.

### NanoServices Self-Document

OpenAPI / Swagger is integrated in the route's .js files. We use **swagger-spec-express** for this allowing a .describe to be added to all routes that require swagger documentation. As a result swagger.json is automatically generated for every NanoService Version with the latest documentation, which is also autogenerated into the /docs/api folder for each Function

### NanoServices Are Externally Verified

In Legacy approaches end to end tests would be necessary to ensure that everything works as expected, but in microservice area's the exact location and scope of such testing is often disputed, especially as traditionally the most test development time is required for end to end or scenario testing.

As all Functions & NanoServices have OpenAPI / Swagger documentation for their public endpoints, **Dredd** is used to parse and test each public endpoint verifying against the generated documentation that the endpoint performs as expected.

End to End tests, are automatic, and encompass the ability to capture breaking changes from external API's & Dependencies (if not caught at the unit test level)

### NanoServices Are Always Versioned

**SemVer** is used extensively to allow smooth updates and releases. All incomming requests pass though any preffered approach the API version to hit. **express-routes-versioning** then routes to the correct endpoint version internally. So patches can be rolled out enforced or easily.

Our default approach and recommendation is that matching SemVers allows for all versions > the released, in case any customers or clients incorrectly type the wrong version so their request still goes through to the intended API version. (This hitting incorrect api version happens a lot, so its good to handle it in the backend)

### External API's NanoServices Interact with are checked

#### Apish

For all API's that use OpenAPI / Swagger or API Blueprint, we can autogenerate mocks against them, swapping in our dependencies against thier specification (which we assume works according to their documentation as it should be auto-generated and tested as **Yūgen** does for you)

**Dredd** then runs against the mocks or they can be used internally

#### Nock

For API's that don't have such excellent integration approaches, Nock is used where the JSON is captured, used for Mocks. The actual JSON we store in the repository (TODO against the relevant external API version), but we also hit their api directly to ensure the object structures you use in your code are still valid and working as expected.


### MicroService is a Collection of Functions

Architecturally **Yūgen** follows the Microservice -> Functions -> NanoServices approach so everything in the base roots directory should be a function and each function should have a set of microservices that enable it to work.
